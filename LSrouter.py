####################################################
# LSrouter.py
# Name: Kenneth Chan , Daniel Gruspier
# BU ID: U88626811
#####################################################

import sys
from collections import defaultdict
from router import Router
from packet import Packet
from json import dumps, loads
import networkx as nx # implement Dijkstra's algorithm as nx.dijkstra_path

class LSrouter(Router):
    """Link state routing protocol implementation."""

    def __init__(self, addr, heartbeatTime):
        """TODO: add your own class fields and initialization code here"""
        Router.__init__(self, addr)  # initialize superclass - don't remove
        self.heartbeatTime = heartbeatTime
        self.last_time = 0
        # Hints: initialize local state
        self.fwd_table = {}				# Format is dstAddr:port
	self.link_state = {}				# Format is addr:cost
	self.neighbors = {}				# Format is addr:port
	self.seq = 0					# Sequence number	
	self.G = nx.Graph()				# For tracking foreign link states
	self.G.add_node(self.addr)			# Add myself to the network graph
	self.most_recent = ''		# For debugging ONLY
	self.all_LS = {}				# Track all routers' link states
	self.all_seqs = {}				# Track all routers' sequence numebrs


    def handlePacket(self, port, packet):
        """TODO: process incoming packet"""
        if packet.isTraceroute():
            # Hints: this is a normal data packet
            # if the forwarding table contains packet.dstAddr
            #   send packet based on forwarding table, e.g., self.send(port, packet)
        	if packet.dstAddr in self.fwd_table:		# If I have dst in my forwarding table
			if self.fwd_table[packet.dstAddr] != 0:		# and there is a path to it...
				self.send(self.fwd_table[packet.dstAddr],packet)	# Forward it accordingly
        else:
            # Hints: this is a routing packet generated by your routing protocol
            # check the sequence number
            # if the sequence number is higher and the received link state is different
            #   update the local copy of the link state
            #   update the forwarding table
            #   broadcast the packet to other neighbors
	    	msg = loads(packet.content)				# De-json the packet content
	    	seq_num = msg[0]					# Take note of the sequence number
	    	recv_state = msg[1]					# Take note of the recv'd link state
        	if not packet.srcAddr in self.all_LS:
          		self.all_seqs[packet.srcAddr] = seq_num - 1
			self.all_LS[packet.srcAddr] = {}
	    	if self.to_update(recv_state,packet.srcAddr) and seq_num > self.all_seqs[packet.srcAddr]:
                	self.all_LS[packet.srcAddr] = recv_state
                	self.all_seqs[packet.srcAddr] = seq_num
                	self.fix_topology(recv_state,packet.srcAddr)
                	self.compute_dijkstra()
                	self.forward_packet(port,packet)


    def handleNewLink(self, port, endpoint, cost):
        """TODO: handle new link"""
        # Hints:
        # update the forwarding table
        # broadcast the new link state of this router to all neighbors
        self.link_state[endpoint] = cost	# Create entry in my link state
	self.neighbors[endpoint] = port		# Create entry in neighbors

	self.fix_topology(self.link_state,self.addr)
	self.compute_dijkstra()

	self.broadcast_LS()

    def handleRemoveLink(self, port):
        """TODO: handle removed link"""
        # Hints:
        # update the forwarding table
        # broadcast the new link state of this router to all neighbors
	
	
	for friend in self.neighbors:			# Identify address where link was
		if self.neighbors[friend] == port:
			to_remove = friend
			break
		    
	self.link_state.pop(to_remove)	# Delete entry from my link state
	self.neighbors.pop(to_remove)	# Delete entry from my neighbors
	
	self.fix_topology(self.link_state,self.addr)
	self.compute_dijkstra()
			
	self.broadcast_LS()   

    def handleTime(self, timeMillisecs):
        """TODO: handle current time"""
        if timeMillisecs - self.last_time >= self.heartbeatTime:
            self.last_time = timeMillisecs
            # Hints:
            # broadcast the link state of this router to all neighbors
            #for neighbor in link_state:
	    #	self.send(neighbor,link_state)
		#pass
	    self.seq = self.seq - 1
	    self.broadcast_LS()

    def debugString(self):
        """TODO: generate a string for debugging in network visualizer"""
	table_str = ''
	for dst in self.fwd_table:
		table_str = table_str + 'For ' + str(dst) + ' forward to ' + str(self.fwd_table[dst]) + '\n'
        return 'LS: ' + str(self.link_state) + '\n Neighbors: ' + str(self.neighbors) + '\nI have ' + str(len(self.neighbors)) + ' neighbors.' +\
			'\nThere are ' + str(len(self.all_LS)) +' other routers in my network topology' + \
			"\n This router's seq num: " + str(self.seq) \
			+ '\n' + table_str #+ '\nGraph includes ' + str([key for key in dict(list(self.G)).keys()])

    def compute_dijkstra(self):
        for n in [n for n in list(self.G) if not n == self.addr]:
		try:
			path = nx.dijkstra_path(self.G,self.addr,n,'weight')	# Calculate best path to each entry
			self.fwd_table[n] = self.neighbors[path[1]]	# path = [me, neighbor, ...]		
		except:
			continue
		    
    def to_update(self,LS,addr):
        if LS == self.all_LS[addr]:
		return False
	else:
            	return True
        
    def fix_topology(self,LS,addr):

        if not self.G.has_node(addr):
            self.G.add_node(addr)
        LS_nodes = [node for node in LS.keys()]
        self.G.add_nodes_from(LS_nodes)
        
        remove = [(me,friend) for me,friend in list(self.G.edges(addr))]
	self.G.remove_edges_from(remove)

	new_edges = [(addr,friend,w) for friend, w in LS.items()]
	self.G.add_weighted_edges_from(new_edges)


    def forward_packet(self,recvd_port,packet):
        for dst in [dst for dst in self.neighbors if not self.neighbors[dst] == recvd_port]:
            		self.send(self.neighbors[dst],packet)			


    def broadcast_LS(self):
	self.seq += 1
        for dst in self.neighbors:	# Forward to all neighbors
		pkt = Packet(kind=Packet.ROUTING,srcAddr=self.addr,dstAddr=dst)	# Make a routing packet
		pkt.content = dumps([self.seq,self.link_state])			# Convert seq num and my LS to JSON
		self.send(self.neighbors[dst],pkt) 
