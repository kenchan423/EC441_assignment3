####################################################
# DVrouter.py
# Name:
# BU ID:
#####################################################

import sys
from collections import defaultdict
from router import Router
from packet import Packet
from json import dumps, loads

import networkx as nx


class DVrouter(Router):
	"""Distance vector routing protocol implementation."""

	def __init__(self, addr, heartbeatTime):
		"""TODO: add your own class fields and initialization code here"""
		Router.__init__(self, addr)  # initialize superclass - don't remove
		self.heartbeatTime = heartbeatTime
		self.last_time = 0
		# Hints: initialize local state

		# format: destination : distance aka cost
		self.dis_vec = {}
		# format: destination : distance vector
		self.all_dis_vec = {}

		# format: addr: port
		self.neighbors = {}

		# format dstAddr:port
		self.fwd_table = {}

		# for debugging
		self.most_recent = ''
		pass

	def handlePacket(self, port, packet):
		"""TODO: process incoming packet"""
		if packet.isTraceroute():
			# Hints: this is a normal data packet
			# if the forwarding table contains packet.dstAddr
			#   send packet based on forwarding table, e.g., self.send(port, packet)

			# if destination in forwarding table
			if packet.dstAddr in self.fwd_table:
				# and if forwarding table has a port (router) for that destination
				if self.fwd_table[packet.dstAddr] != 0:
					# send the pkt
					self.send(self.fwd_table[packet.dstAddr], packet)
			pass
		else:
			# Hints: this is a routing packet generated by your routing protocol
			# if the received distance vector is different
			#   update the local copy of the distance vector
			#   update the distance vector of this router
			#   update the forwarding table
			#   broadcast the distance vector of this router to neighbors

			# de-json packet content
			recv_dis_vec = loads(packet.content)
			# recv_dis_vec came as a vec --> so must index 0 to get it as dict
			self.most_recent = recv_dis_vec

			# update local copy of distance vector
			# if there's an DV for that address ...
			update = False
			if packet.srcAddr in self.all_dis_vec:
				# if the DV recieved and the current entry are different
				if not recv_dis_vec == self.all_dis_vec[packet.srcAddr]:
					   self.all_dis_vec[packet.srcAddr] = recv_dis_vec
					   update = True
				else:
					pass
			else:
				# otherwise, there is yet a DV for that address --> must add DV
				self.all_dis_vec[packet.srcAddr] = recv_dis_vec
				update = True

			# add src's neighbors to forward table --> discovering new nodes
			# dont add myself (b/c first condition doesnt tick since not in my own fowarding table)
			# initalize address: port --> 0
			if update == True:
				for address in recv_dis_vec:
					if not address in self.fwd_table and not address == self.addr:
						self.fwd_table[address] = 0
					if not packet.srcAddr in self.fwd_table:
						self.fwd_table[packet.srcAddr] = 0

			# re-calculate DV
			# # no need to pass self b/c ...
			# 'Python automatically adds in first self argument for bound methods'
			
			#self.bellmanFord(packet.dstAddr)
				for dst in self.fwd_table:
					self.bellmanFord(dst)
				'''
				# broadcast DV
				for dst in self.neighbors:
					pkt = Packet(kind=Packet.ROUTING, srcAddr=self.addr, dstAddr=dst)
					pkt.content = dumps(self.dis_vec)
					self.send(self.neighbors[dst], pkt)
				'''
		
				# broadcast DV
				for dst in self.neighbors:
					pkt = Packet(kind=Packet.ROUTING, srcAddr=self.addr, dstAddr=dst)
					# poisoned reverse
					# when sending DV to specific neighbor
					dv_content = self.dis_vec.copy()
					neighbor_port = self.neighbors[dst]
					for poisoned_dst, route in self.fwd_table.items():
						# for that neighbor --> if self routes through that neighbor for x dst
						if neighbor_port == route:
							# change DV for all those x dst to infinity
							# thus, neighbor never routes through self for x dst
							dv_content[poisoned_dst]=16
					pkt.content = dumps(dv_content)
					self.send(self.neighbors[dst], pkt)	
			


	def handleNewLink(self, port, endpoint, cost):
		"""TODO: handle new link"""
		# update the distance vector of this router
		# update the forwarding table
		# broadcast the distance vector of this router to neighbors

		# create new entry in own distance vector, neighbors, fowarding table
		self.dis_vec[endpoint] = cost
		self.neighbors[endpoint] = port
		self.fwd_table[endpoint] = port

		for dst in self.fwd_table:
			self.bellmanFord(dst)

		# fowarding to neighbors
		for dst in self.neighbors:
			pkt = Packet(kind=Packet.ROUTING, srcAddr=self.addr, dstAddr=dst)
			pkt.content = dumps(self.dis_vec)
			self.send(self.neighbors[dst], pkt)

	def handleRemoveLink(self, port):
		"""TODO: handle removed link"""
		# update the distance vector of this router
		# update the forwarding table
		# broadcast the distance vector of this router to neighbors

		# update distance vector
		# which neighbor matches to that port
		for friend in self.neighbors:
			if self.neighbors[friend] == port:
				to_remove = friend
				break
		# remove that entry from neighbors & DV
		self.neighbors.pop(to_remove)
		self.dis_vec[to_remove] = 16

		for dst in self.fwd_table:
			self.bellmanFord(dst)

		# forward to all neighbors
		for dst in self.neighbors:
			pkt = Packet(kind=Packet.ROUTING, srcAddr=self.addr, dstAddr=dst)
			pkt.content = dumps(self.dis_vec)
			self.send(self.neighbors[dst], pkt)

	def handleTime(self, timeMillisecs):
		"""TODO: handle current time"""
		if timeMillisecs - self.last_time >= self.heartbeatTime:
			self.last_time = timeMillisecs
			# broadcast the distance vector of this router to neighbors
			# forward to all neighbors
			for dst in self.neighbors:
				pkt = Packet(kind=Packet.ROUTING, srcAddr=self.addr, dstAddr=dst)
				pkt.content = dumps(self.dis_vec)
				self.send(self.neighbors[dst], pkt)

	def debugString(self):
		"""TODO: generate a string for debugging in network visualizer"""
		fwd_str = ''
		for dst in self.fwd_table:
			fwd_str = fwd_str + '\nFor ' + dst + \
			' forward to port ' + str(self.fwd_table[dst])
		return 'Own DV: ' + str(self.dis_vec) + \
			'\nNeighbors: ' + str(self.neighbors) +\
			'\nNum. of Neighbors: ' + str(len(self.neighbors)) +\
			'\nNum. of Routers: ' + str(len(self.all_dis_vec)) +\
			fwd_str +\
			'\nAll DVs: ' + str(self.all_dis_vec)

	def bellmanFord(self, dst):
		# No clue if this works :'(

		# objective: find the lowest cost from current (self) --> destination
		# first, go through each neighbor & their DV's --> add cost of self to neighbor + cost of neighbor to destination

		bell = {}
		# go through each neighbor
		for friend in self.neighbors:
			# cost of self --> neighbor
			friend_cost = self.dis_vec[friend]
			# cost of neighbor --> dst
			if friend not in self.all_dis_vec:
				continue
			friend_dv = self.all_dis_vec[friend]
			if not dst in friend_dv:
				continue
			fri_to_dst = friend_dv[dst]
			# total cost = self-->neighbor + neighbor-->dst
			current_cost = friend_cost + fri_to_dst
			# re-writing lowest cost if the cost of going through current neighbor is less
			if dst in self.dis_vec:
				if current_cost > self.dis_vec[dst] and dst in self.neighbors:
					current_cost = self.dis_vec[dst]
					bell[current_cost] = self.neighbors[dst]
				else:
					bell[current_cost] = self.fwd_table[friend]
			else:
				bell[current_cost] = self.fwd_table[friend]
		if bell:
			lowest_cost = min(list(bell.keys()))
			self.dis_vec[dst] = lowest_cost
			self.fwd_table[dst] = bell[lowest_cost]
		# returning lowest cost into dis_vec
		#self.dis_vec[dst] = lowest_cost
		# adding port for that dst --> based on cheapest_friend (lowest_cost)
		#self.fwd_table[dst] = self.neighbors[cheapest_friend]
